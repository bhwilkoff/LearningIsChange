<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Static Blog Post Generator v2</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <link href="https://cdn.quilljs.com/1.3.7/quill.snow.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Open+Sans:wght@300;400;600;700&family=Open+Sans+Condensed:wght@300&display=swap');
        
        :root {
            --accent-1: #0085b2;
            --accent-1-hover: #006d91;
            --accent-2: #f42b00;
            --headings: #333;
            --sitetext: #555;
            --sitebg: #fff;
            --light-bg: #f7f7f7;
            --border-color: #e0e0e0;
            --success: #28a745;
            --success-hover: #218838;
        }
        
        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: var(--light-bg);
            color: var(--sitetext);
            line-height: 1.6;
        }
        
        /* Header styling to match site */
        .site-header {
            background: var(--accent-1);
            color: white;
            padding: 25px 30px;
            margin: -20px -20px 30px -20px;
            border-bottom: 4px solid var(--accent-1-hover);
        }
        .site-header h1 {
            margin: 0 0 5px 0;
            font-size: 1.8em;
            font-weight: 300;
            font-family: 'Open Sans Condensed', 'Open Sans', sans-serif;
            letter-spacing: 0.5px;
        }
        .site-header .subtitle {
            margin: 0;
            opacity: 0.9;
            font-size: 0.95em;
            font-weight: 300;
        }
        
        h1, h2, h3 {
            color: var(--headings);
            font-weight: 600;
        }
        
        .step {
            background: var(--sitebg);
            padding: 25px;
            margin-bottom: 20px;
            border-radius: 3px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border: 1px solid var(--border-color);
        }
        .step h2 {
            margin-top: 0;
            color: var(--headings);
            font-size: 1.2em;
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 600;
        }
        .step-number {
            background: var(--accent-1);
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85em;
            flex-shrink: 0;
            font-weight: 600;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--headings);
            font-size: 0.95em;
        }
        input[type="text"], input[type="date"] {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            font-size: 15px;
            font-family: inherit;
            transition: border-color 0.2s, box-shadow 0.2s;
            color: var(--sitetext);
        }
        input[type="text"]:focus, input[type="date"]:focus {
            outline: none;
            border-color: var(--accent-1);
            box-shadow: 0 0 0 2px rgba(0, 133, 178, 0.15);
        }
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        @media (max-width: 600px) {
            .form-row {
                grid-template-columns: 1fr;
            }
        }
        .form-group {
            margin-bottom: 20px;
        }
        #editor-container {
            height: 400px;
            background: white;
        }
        .ql-toolbar {
            border-radius: 3px 3px 0 0;
            background: var(--light-bg);
            border-color: var(--border-color) !important;
        }
        .ql-container {
            border-radius: 0 0 3px 3px;
            font-size: 15px;
            font-family: inherit;
            border-color: var(--border-color) !important;
        }
        .ql-editor {
            font-family: 'Open Sans', sans-serif;
        }
        .file-upload {
            border: 2px dashed var(--border-color);
            padding: 25px;
            text-align: center;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--light-bg);
            margin-bottom: 15px;
        }
        .file-upload:hover {
            border-color: var(--accent-1);
            background: rgba(0, 133, 178, 0.03);
        }
        .file-upload.has-file {
            border-color: var(--success);
            background: rgba(40, 167, 69, 0.05);
            border-style: solid;
        }
        .file-upload input {
            display: none;
        }
        .file-upload-icon {
            font-size: 32px;
            margin-bottom: 8px;
        }
        .file-upload strong {
            color: var(--headings);
        }
        .btn {
            background: var(--accent-1);
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 15px;
            font-family: inherit;
            border-radius: 3px;
            cursor: pointer;
            transition: background 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }
        .btn:hover {
            background: var(--accent-1-hover);
        }
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .btn-generate {
            background: var(--success);
            width: 100%;
            justify-content: center;
            font-size: 17px;
            padding: 15px;
        }
        .btn-generate:hover {
            background: var(--success-hover);
        }
        .image-upload-area {
            margin-top: 20px;
            padding: 20px;
            background: var(--light-bg);
            border-radius: 3px;
            border: 1px solid var(--border-color);
        }
        .image-upload-area label {
            margin-bottom: 10px;
        }
        .image-list {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 15px;
        }
        .image-item {
            position: relative;
            width: 120px;
        }
        .image-item img {
            width: 100%;
            height: 80px;
            object-fit: cover;
            border-radius: 3px;
            border: 1px solid var(--border-color);
        }
        .image-item .image-path {
            font-size: 10px;
            word-break: break-all;
            color: #888;
            margin-top: 4px;
        }
        .image-item .remove-image {
            position: absolute;
            top: -8px;
            right: -8px;
            background: var(--accent-2);
            color: white;
            border: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
        }
        .copy-path {
            background: #6c757d;
            color: white;
            border: none;
            padding: 3px 8px;
            font-size: 10px;
            border-radius: 3px;
            cursor: pointer;
            margin-top: 4px;
        }
        .insert-image {
            background: var(--accent-1);
            color: white;
            border: none;
            padding: 3px 8px;
            font-size: 10px;
            border-radius: 3px;
            cursor: pointer;
            margin-top: 4px;
            margin-right: 4px;
        }
        .insert-image:hover {
            background: var(--accent-1-hover);
        }
        .status {
            padding: 15px;
            border-radius: 3px;
            margin-top: 20px;
            display: none;
        }
        .status.success {
            background: rgba(40, 167, 69, 0.1);
            color: #155724;
            border: 1px solid rgba(40, 167, 69, 0.3);
            display: block;
        }
        .status.error {
            background: rgba(244, 43, 0, 0.1);
            color: #721c24;
            border: 1px solid rgba(244, 43, 0, 0.3);
            display: block;
        }
        .status.info {
            background: rgba(0, 133, 178, 0.1);
            color: #004085;
            border: 1px solid rgba(0, 133, 178, 0.3);
            display: block;
        }
        .slug-preview {
            font-size: 13px;
            color: #888;
            margin-top: 6px;
        }
        .slug-preview code {
            background: var(--light-bg);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: var(--accent-1);
        }
        .help-text {
            font-size: 13px;
            color: #888;
            margin-top: 5px;
        }
        .fetch-github-section {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(35, 134, 54, 0.05);
            border-radius: 3px;
            border: 1px solid rgba(35, 134, 54, 0.2);
        }
        .fetch-status {
            width: 100%;
            margin-top: 10px;
            font-size: 14px;
            display: none;
        }
        .fetch-status.show {
            display: block;
        }
        .fetch-status.success {
            color: #155724;
        }
        .fetch-status.error {
            color: #721c24;
        }
        .fetch-status.loading {
            color: var(--accent-1);
        }
        .or-divider {
            display: flex;
            align-items: center;
            text-align: center;
            margin: 20px 0;
            color: #888;
            font-size: 13px;
        }
        .or-divider::before,
        .or-divider::after {
            content: '';
            flex: 1;
            border-bottom: 1px solid var(--border-color);
        }
        .or-divider span {
            padding: 0 15px;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 12px;
        }
        .checkbox-group input {
            width: 16px;
            height: 16px;
            accent-color: var(--accent-1);
        }
        .checkbox-group label {
            margin: 0;
            font-weight: normal;
            color: var(--sitetext);
        }
        .preview-section {
            margin-top: 20px;
            padding: 20px;
            background: rgba(40, 167, 69, 0.05);
            border-radius: 3px;
            border: 1px solid rgba(40, 167, 69, 0.2);
            display: none;
        }
        .preview-section.show {
            display: block;
        }
        .preview-section h3 {
            margin-top: 0;
            color: var(--success);
        }
        .downloads {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        .file-list {
            margin-top: 15px;
            font-size: 14px;
            padding-left: 20px;
        }
        .file-list li {
            margin-bottom: 6px;
            font-family: 'Courier New', monospace;
            color: var(--accent-1);
        }
        .upload-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        @media (max-width: 700px) {
            .upload-grid {
                grid-template-columns: 1fr;
            }
        }
        .extracted-info {
            background: rgba(0, 133, 178, 0.05);
            padding: 15px 20px;
            border-radius: 3px;
            margin-top: 15px;
            font-size: 14px;
            border: 1px solid rgba(0, 133, 178, 0.15);
        }
        .extracted-info h4 {
            margin: 0 0 10px 0;
            color: var(--accent-1);
            font-weight: 600;
        }
        .extracted-info ul {
            margin: 0;
            padding-left: 20px;
            color: var(--sitetext);
        }
        .extracted-info li {
            margin-bottom: 4px;
        }
        .tag-input {
            display: flex;
            gap: 10px;
        }
        .tag-input input {
            flex: 1;
        }
        .tag-input button {
            padding: 10px 18px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-family: inherit;
            font-weight: 600;
        }
        .tag-input button:hover {
            background: #5a6268;
        }
        .tags-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        .tag {
            background: var(--accent-1);
            color: white;
            padding: 4px 10px;
            border-radius: 3px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .tag button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
            color: rgba(255,255,255,0.8);
            padding: 0;
        }
        .tag button:hover {
            color: white;
        }
        
        /* Category/Tag Selection UI */
        .taxonomy-section {
            margin-bottom: 15px;
        }
        .taxonomy-section label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }
        .taxonomy-select-wrapper {
            position: relative;
        }
        .taxonomy-select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            font-family: inherit;
            font-size: 14px;
            background: white;
            cursor: pointer;
        }
        .taxonomy-select:focus {
            outline: none;
            border-color: var(--accent-1);
        }
        .taxonomy-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid var(--border-color);
            border-top: none;
            border-radius: 0 0 3px 3px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }
        .taxonomy-dropdown.show {
            display: block;
        }
        .taxonomy-option {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
        }
        .taxonomy-option:last-child {
            border-bottom: none;
        }
        .taxonomy-option:hover {
            background: var(--light-bg);
        }
        .taxonomy-option.nested {
            padding-left: 24px;
            font-size: 13px;
        }
        .taxonomy-option.nested::before {
            content: "‚Ü≥ ";
            color: #999;
        }
        .taxonomy-option.add-new {
            background: #f8f9fa;
            color: var(--accent-1);
            font-weight: 600;
            border-top: 2px solid var(--border-color);
        }
        .taxonomy-option.add-new:hover {
            background: #e9ecef;
        }
        .new-taxonomy-form {
            display: none;
            margin-top: 10px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 3px;
            border: 1px solid var(--border-color);
        }
        .new-taxonomy-form.show {
            display: block;
        }
        .new-taxonomy-form input,
        .new-taxonomy-form select {
            width: 100%;
            padding: 8px 10px;
            margin-bottom: 8px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            font-family: inherit;
            font-size: 14px;
        }
        .new-taxonomy-form label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
        }
        .new-taxonomy-form .form-row-inline {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .new-taxonomy-form button {
            padding: 8px 16px;
            font-size: 13px;
        }
        .taxonomy-badge {
            display: inline-block;
            background: var(--accent-1);
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 11px;
            margin-left: 8px;
            vertical-align: middle;
        }
        .taxonomy-badge.fetched {
            background: var(--success);
        }
        .existing-taxonomies {
            margin-top: 8px;
            font-size: 12px;
            color: #666;
        }
        .existing-taxonomies span {
            display: inline-block;
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            margin: 2px;
            cursor: pointer;
        }
        .existing-taxonomies span:hover {
            background: #dee2e6;
        }
        
        /* Collapsible GitHub Settings */
        .collapsible-section {
            border: 1px solid var(--border-color);
            border-radius: 3px;
            margin-top: 20px;
            background: var(--sitebg);
        }
        .collapsible-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px 20px;
            cursor: pointer;
            background: var(--light-bg);
            border-radius: 3px 3px 0 0;
            transition: background 0.2s;
        }
        .collapsible-header:hover {
            background: #eee;
        }
        .collapsible-header h3 {
            margin: 0;
            font-size: 1em;
            font-weight: 600;
            color: var(--headings);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .collapsible-header .toggle-icon {
            transition: transform 0.2s;
            font-size: 0.9em;
        }
        .collapsible-section.open .toggle-icon {
            transform: rotate(180deg);
        }
        .collapsible-content {
            display: none;
            padding: 20px;
            border-top: 1px solid var(--border-color);
        }
        .collapsible-section.open .collapsible-content {
            display: block;
        }
        .github-settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        @media (max-width: 600px) {
            .github-settings-grid {
                grid-template-columns: 1fr;
            }
        }
        .github-settings-grid .form-group {
            margin-bottom: 0;
        }
        .token-input-wrapper {
            position: relative;
        }
        .token-input-wrapper input {
            padding-right: 45px;
        }
        .token-toggle {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            padding: 5px;
            color: #888;
        }
        .token-toggle:hover {
            color: var(--accent-1);
        }
        .save-token-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }
        .save-token-group input[type="checkbox"] {
            width: 14px;
            height: 14px;
            accent-color: var(--accent-1);
        }
        .save-token-group label {
            font-size: 13px;
            color: #666;
            margin: 0;
            font-weight: normal;
        }
        .github-status {
            margin-top: 15px;
            padding: 12px 15px;
            border-radius: 3px;
            font-size: 14px;
            display: none;
        }
        .github-status.connected {
            background: rgba(40, 167, 69, 0.1);
            color: #155724;
            border: 1px solid rgba(40, 167, 69, 0.3);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .github-status.disconnected {
            background: rgba(108, 117, 125, 0.1);
            color: #495057;
            border: 1px solid rgba(108, 117, 125, 0.3);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .btn-github {
            background: #238636;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .btn-github:hover {
            background: #2ea043;
        }
        .btn-github:disabled {
            background: #94d3a2;
        }
        .btn-secondary {
            background: #6c757d;
        }
        .btn-secondary:hover {
            background: #5a6268;
        }
        .publish-actions {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        .progress-container {
            margin-top: 15px;
            display: none;
        }
        .progress-container.show {
            display: block;
        }
        .progress-bar-wrapper {
            background: #e9ecef;
            border-radius: 3px;
            height: 8px;
            overflow: hidden;
        }
        .progress-bar {
            background: var(--accent-1);
            height: 100%;
            width: 0%;
            transition: width 0.3s;
        }
        .progress-text {
            font-size: 13px;
            color: #666;
            margin-top: 8px;
        }
        
        /* Footer */
        .site-footer {
            text-align: center;
            padding: 20px;
            margin-top: 30px;
            color: #888;
            font-size: 13px;
            border-top: 1px solid var(--border-color);
        }
        .site-footer a {
            color: var(--accent-1);
            text-decoration: none;
        }
        .site-footer a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <header class="site-header">
        <h1>Static Blog Post Generator</h1>
        <p class="subtitle">Create new posts for Learning is Change with full navigation, sidebar, and archive support</p>
    </header>

    <div class="step">
        <h2><span class="step-number">1</span> Load Site Files</h2>
        <p class="help-text">Load your existing site files so the generator can extract the header, navigation, sidebar, and footer.</p>
        
        <!-- Fetch from GitHub option -->
        <div class="fetch-github-section">
            <button class="btn btn-github" id="fetchFromGithub" onclick="fetchFromGithub()">
                <svg height="16" width="16" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path></svg>
                Fetch from GitHub
            </button>
            <span class="help-text" style="margin-left: 10px;">Requires GitHub token in settings below</span>
            <div id="fetchStatus" class="fetch-status"></div>
        </div>
        
        <div class="or-divider">
            <span>or upload manually</span>
        </div>
        
        <div class="upload-grid">
            <div>
                <div class="file-upload" id="homepageUpload">
                    <div class="file-upload-icon">üè†</div>
                    <div><strong>Homepage</strong> (index.html)</div>
                    <div class="help-text">Main site homepage</div>
                    <input type="file" id="homepageFile" accept=".html">
                </div>
            </div>
            <div>
                <div class="file-upload" id="archiveUpload">
                    <div class="file-upload-icon">üìÖ</div>
                    <div><strong>Archive Page</strong> (optional)</div>
                    <div class="help-text">Existing month archive to update</div>
                    <input type="file" id="archiveFile" accept=".html">
                </div>
            </div>
        </div>
        
        <div id="extractedInfo" class="extracted-info" style="display: none;">
            <h4>‚úÖ Extracted from your site:</h4>
            <ul id="extractedList"></ul>
        </div>
    </div>

    <div class="step">
        <h2><span class="step-number">2</span> Post Details</h2>
        <div class="form-row">
            <div class="form-group">
                <label for="postTitle">Post Title *</label>
                <input type="text" id="postTitle" placeholder="My Amazing New Post">
            </div>
            <div class="form-group">
                <label for="postDate">Post Date *</label>
                <input type="date" id="postDate">
            </div>
        </div>
        <div class="form-group">
            <label for="postSlug">URL Slug (optional - auto-generated from title)</label>
            <input type="text" id="postSlug" placeholder="my-amazing-new-post">
            <div class="slug-preview">Post URL: <code id="slugPreview">/2025/12/11/my-amazing-new-post/</code></div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label for="postCategory">
                    Category
                    <span class="taxonomy-badge fetched" id="categoryBadge" style="display:none;">0 fetched</span>
                </label>
                <div class="taxonomy-select-wrapper">
                    <input type="text" class="taxonomy-select" id="postCategory" placeholder="Type to search or add new..." value="uncategorized" autocomplete="off">
                    <div class="taxonomy-dropdown" id="categoryDropdown"></div>
                </div>
                <div class="new-taxonomy-form" id="newCategoryForm">
                    <div class="form-row-inline">
                        <div>
                            <label for="parentCategory">Parent category (optional)</label>
                            <select id="parentCategory">
                                <option value="">No parent (top-level)</option>
                            </select>
                        </div>
                        <div>
                            <label for="newCategorySlug">New category slug</label>
                            <input type="text" id="newCategorySlug" placeholder="e.g., my-new-category">
                        </div>
                    </div>
                    <div id="categoryPreview" style="font-size: 12px; color: #666; margin-bottom: 8px;"></div>
                    <button type="button" onclick="addNewCategory()">‚úì Add Category</button>
                    <button type="button" onclick="cancelNewCategory()" style="background:#6c757d;">‚úï Cancel</button>
                </div>
            </div>
            <div class="form-group">
                <label>
                    Tags
                    <span class="taxonomy-badge fetched" id="tagBadge" style="display:none;">0 fetched</span>
                </label>
                <div class="tag-input">
                    <input type="text" id="tagInput" placeholder="Type to search or add new..." list="existingTagsList" autocomplete="off">
                    <datalist id="existingTagsList"></datalist>
                    <button type="button" onclick="addTag()">Add</button>
                </div>
                <div class="tags-list" id="tagsList"></div>
                <div class="existing-taxonomies" id="existingTagsHint" style="display:none;">
                    Click to add: <span id="existingTagsQuickAdd"></span>
                </div>
            </div>
        </div>
    </div>

    <div class="step">
        <h2><span class="step-number">3</span> Write Your Post</h2>
        <div id="editor-container"></div>
        
        <div class="image-upload-area">
            <label>üì∑ Add Images to Your Post</label>
            <input type="file" id="imageFiles" multiple accept="image/*">
            <div class="help-text">Upload images here, then click <strong>"‚ûï Insert"</strong> to add them to your post at the cursor position.</div>
            <div class="image-list" id="imageList"></div>
        </div>
    </div>

    <div class="step">
        <h2><span class="step-number">4</span> Output Options</h2>
        <div class="checkbox-group">
            <input type="checkbox" id="updateHomepage" checked>
            <label for="updateHomepage" style="margin: 0; font-weight: normal;">Update homepage with new post</label>
        </div>
        <div class="checkbox-group">
            <input type="checkbox" id="createPostPage" checked>
            <label for="createPostPage" style="margin: 0; font-weight: normal;">Create individual post page (/YYYY/MM/DD/slug/)</label>
        </div>
        <div class="checkbox-group">
            <input type="checkbox" id="updateArchive" checked>
            <label for="updateArchive" style="margin: 0; font-weight: normal;">Create/update monthly archive page (/YYYY/MM/)</label>
        </div>
        <div class="checkbox-group">
            <input type="checkbox" id="updateYearlyArchive" checked>
            <label for="updateYearlyArchive" style="margin: 0; font-weight: normal;">Create/update yearly archive page (/YYYY/)</label>
        </div>
        
        <!-- GitHub Settings Collapsible -->
        <div class="collapsible-section" id="githubSettings">
            <div class="collapsible-header" onclick="toggleGithubSettings()">
                <h3>‚öôÔ∏è GitHub Publishing Settings</h3>
                <span class="toggle-icon">‚ñº</span>
            </div>
            <div class="collapsible-content">
                <p class="help-text" style="margin-top: 0; margin-bottom: 15px;">
                    Configure these settings to publish directly to your GitHub Pages repository. 
                    <a href="https://github.com/settings/tokens?type=beta" target="_blank" style="color: var(--accent-1);">Create a fine-grained token</a> 
                    with "Contents" read/write permission for your repo.
                </p>
                
                <div class="github-settings-grid">
                    <div class="form-group">
                        <label for="githubToken">Personal Access Token</label>
                        <div class="token-input-wrapper">
                            <input type="password" id="githubToken" placeholder="github_pat_...">
                            <button type="button" class="token-toggle" onclick="toggleTokenVisibility()" title="Show/hide token">üëÅÔ∏è</button>
                        </div>
                        <div class="save-token-group">
                            <input type="checkbox" id="saveToken">
                            <label for="saveToken">Remember token in this browser</label>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="githubRepo">Repository</label>
                        <input type="text" id="githubRepo" value="bhwilkoff/LearningIsChange" placeholder="owner/repo">
                    </div>
                    <div class="form-group">
                        <label for="committerName">Committer Name</label>
                        <input type="text" id="committerName" value="Ben Wilkoff" placeholder="Your Name">
                    </div>
                    <div class="form-group">
                        <label for="committerEmail">Committer Email</label>
                        <input type="text" id="committerEmail" value="Ben@learningischange.com" placeholder="you@example.com">
                    </div>
                </div>
                
                <div class="publish-actions">
                    <button class="btn btn-secondary" onclick="testGithubConnection()">üîó Test Connection</button>
                    <button class="btn btn-secondary" onclick="clearGithubSettings()">üóëÔ∏è Clear Saved Settings</button>
                </div>
                
                <div class="github-status" id="githubStatus"></div>
            </div>
        </div>
    </div>

    <div class="step">
        <h2><span class="step-number">5</span> Generate &amp; Publish</h2>
        <button class="btn btn-generate" id="generateBtn" disabled>
            üöÄ Generate Post Files
        </button>
        
        <div id="statusMessage" class="status"></div>
        
        <div class="preview-section" id="downloadSection">
            <h3>‚úÖ Files Generated!</h3>
            <p>Your files are ready. Choose how to publish:</p>
            <ul class="file-list" id="fileList"></ul>
            <div class="publish-actions">
                <button class="btn" id="downloadZip">üì¶ Download ZIP</button>
                <button class="btn btn-github" id="publishGithub" onclick="publishToGithub()">
                    <svg height="16" width="16" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path></svg>
                    Publish to GitHub
                </button>
            </div>
            
            <div class="progress-container" id="publishProgress">
                <div class="progress-bar-wrapper">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
                <div class="progress-text" id="progressText">Preparing...</div>
            </div>
        </div>
    </div>

    <script src="https://cdn.quilljs.com/1.3.7/quill.min.js"></script>
    <script>
    // Global variables
    let quill;
    let uploadedImages = [];
    let tags = [];
    let generatedFiles = {}; // Stores files for GitHub publishing (path -> content)
    
    // Extracted site components
    let siteComponents = {
        head: null,
        header: null,
        sidebar: null,
        footer: null,
        scripts: null,
        homepageHtml: null,
        archiveHtml: null,
        yearlyArchiveHtml: null
    };

    // Existing categories and tags (fetched from GitHub)
    let existingCategories = []; // [{slug, parent, path}]
    let existingTags = []; // [{slug, path}]
    let selectedCategory = { slug: 'uncategorized', parent: null };

    function initApp() {
        // Check if Quill is loaded
        if (typeof Quill === 'undefined') {
            setTimeout(initApp, 100);
            return;
        }
        
        // Initialize Quill editor
        quill = new Quill('#editor-container', {
            theme: 'snow',
            placeholder: 'Write your blog post here...',
            modules: {
                toolbar: {
                    container: [
                        [{ 'header': [2, 3, 4, false] }],
                        ['bold', 'italic', 'underline', 'strike'],
                        [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                        ['blockquote', 'code-block'],
                        ['link', 'image'],
                        ['clean']
                    ],
                    handlers: {
                        image: function() {
                            const url = prompt('Enter image URL:\n\n‚Ä¢ For uploaded images: Use the "Insert" button below instead\n‚Ä¢ For external images: Enter the full https:// URL');
                            if (url) {
                                const range = quill.getSelection(true);
                                quill.insertEmbed(range.index, 'image', url);
                                quill.setSelection(range.index + 1);
                            }
                        }
                    }
                }
            }
        });

        // Set default date to today
        document.getElementById('postDate').valueAsDate = new Date();

        // File upload handling - Homepage
        const homepageUpload = document.getElementById('homepageUpload');
        const homepageFile = document.getElementById('homepageFile');

        homepageUpload.addEventListener('click', () => homepageFile.click());
        homepageUpload.addEventListener('dragover', (e) => {
            e.preventDefault();
            homepageUpload.style.borderColor = '#0085b2';
        });
        homepageUpload.addEventListener('dragleave', () => {
            homepageUpload.style.borderColor = '#ddd';
        });
        homepageUpload.addEventListener('drop', (e) => {
            e.preventDefault();
            homepageUpload.style.borderColor = '#ddd';
            if (e.dataTransfer.files.length) {
                handleHomepageFile(e.dataTransfer.files[0]);
            }
        });
        homepageFile.addEventListener('change', (e) => {
            if (e.target.files.length) {
                handleHomepageFile(e.target.files[0]);
            }
        });

        // File upload handling - Archive
        const archiveUpload = document.getElementById('archiveUpload');
        const archiveFile = document.getElementById('archiveFile');

        archiveUpload.addEventListener('click', () => archiveFile.click());
        archiveUpload.addEventListener('dragover', (e) => {
            e.preventDefault();
            archiveUpload.style.borderColor = '#0085b2';
        });
        archiveUpload.addEventListener('dragleave', () => {
            archiveUpload.style.borderColor = '#ddd';
        });
        archiveUpload.addEventListener('drop', (e) => {
            e.preventDefault();
            archiveUpload.style.borderColor = '#ddd';
            if (e.dataTransfer.files.length) {
                handleArchiveFile(e.dataTransfer.files[0]);
            }
        });
        archiveFile.addEventListener('change', (e) => {
            if (e.target.files.length) {
                handleArchiveFile(e.target.files[0]);
            }
        });

        function handleHomepageFile(file) {
            if (!file.name.endsWith('.html')) {
                alert('Please upload an HTML file');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const html = e.target.result;
                siteComponents.homepageHtml = html;
                
                // Extract components
                extractSiteComponents(html);
                
                homepageUpload.classList.add('has-file');
                homepageUpload.innerHTML = `
                    <div class="file-upload-icon">‚úÖ</div>
                    <div><strong>${file.name}</strong></div>
                    <div class="help-text">Click to change</div>
                    <input type="file" id="homepageFile" accept=".html">
                `;
                document.getElementById('homepageFile').addEventListener('change', (e) => {
                    if (e.target.files.length) handleHomepageFile(e.target.files[0]);
                });
                
                updateExtractedInfo();
                updateGenerateButton();
            };
            reader.readAsText(file);
        }

        function handleArchiveFile(file) {
            if (!file.name.endsWith('.html')) {
                alert('Please upload an HTML file');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                siteComponents.archiveHtml = e.target.result;
                
                archiveUpload.classList.add('has-file');
                archiveUpload.innerHTML = `
                    <div class="file-upload-icon">‚úÖ</div>
                    <div><strong>${file.name}</strong></div>
                    <div class="help-text">Click to change</div>
                    <input type="file" id="archiveFile" accept=".html">
                `;
                document.getElementById('archiveFile').addEventListener('change', (e) => {
                    if (e.target.files.length) handleArchiveFile(e.target.files[0]);
                });
                
                updateExtractedInfo();
            };
            reader.readAsText(file);
        }

        function extractSiteComponents(html) {
            // Extract <head> content
            const headMatch = html.match(/<head[^>]*>([\s\S]*?)<\/head>/i);
            if (headMatch) {
                siteComponents.head = headMatch[1];
            }

            // Extract full header: from after <body...> opening tag to </header><!-- #masthead -->
            // This includes the site-wrapper div, skip-link, and full header with navigation
            const bodyMatch = html.match(/<body[^>]*>([\s\S]*?<\/header><!-- #masthead -->)/i);
            if (bodyMatch) {
                let headerContent = bodyMatch[1];
                // Make sure we have the site-wrapper opening
                if (!headerContent.includes('id="site-wrapper"')) {
                    headerContent = '<div id="site-wrapper">\n' + headerContent;
                }
                siteComponents.header = headerContent;
            }

            // Extract sidebar (the aside with archive links)
            const sidebarMatch = html.match(/(<aside id="primary"[\s\S]*?<\/aside>)\s*\n?\s*<\/div><!-- #container -->/i);
            if (sidebarMatch) {
                siteComponents.sidebar = sidebarMatch[1];
            }

            // Extract footer section: colophon, #main close (which closes #content), footer, site-wrapper close
            const footerMatch = html.match(/(<aside id="colophon"[\s\S]*?<\/div><!-- site-wrapper -->)/i);
            if (footerMatch) {
                siteComponents.footer = footerMatch[1];
            } else {
                // Fallback: construct from pieces
                const colophonMatch = html.match(/(<aside id="colophon"[\s\S]*?<\/aside><!-- #colophon -->)/i);
                const footerElemMatch = html.match(/(<footer id="footer"[\s\S]*?<\/footer>)/i);
                if (colophonMatch && footerElemMatch) {
                    siteComponents.footer = colophonMatch[1] + '\n\n\t</div><!-- #main -->\n\n\t' + footerElemMatch[1] + '\n\n\t</div><!-- site-wrapper -->';
                }
            }

            // Extract scripts at the end (everything after site-wrapper close up to </body>)
            const scriptsMatch = html.match(/<\/div><!-- site-wrapper -->([\s\S]*?)<\/body>/i);
            if (scriptsMatch) {
                siteComponents.scripts = scriptsMatch[1].trim();
            } else {
                // Try from after </footer>
                const altScriptsMatch = html.match(/<\/footer>([\s\S]*?)<\/body>/i);
                if (altScriptsMatch) {
                    let scripts = altScriptsMatch[1].replace(/<\/div><!-- site-wrapper -->/gi, '').trim();
                    siteComponents.scripts = scripts;
                }
            }
        }

        function updateExtractedInfo() {
            const info = document.getElementById('extractedInfo');
            const list = document.getElementById('extractedList');
            
            const items = [];
            if (siteComponents.head) items.push('‚úì Page head (styles, meta tags)');
            if (siteComponents.header) items.push('‚úì Header with navigation menu');
            if (siteComponents.sidebar) items.push('‚úì Sidebar with archive links');
            if (siteComponents.footer) items.push('‚úì Footer');
            if (siteComponents.scripts) items.push('‚úì Scripts (masonry, etc.)');
            if (siteComponents.archiveHtml) items.push('‚úì Archive page template');
            
            if (items.length > 0) {
                list.innerHTML = items.map(item => `<li>${item}</li>`).join('');
                info.style.display = 'block';
            }
        }

        // Title to slug conversion
        document.getElementById('postTitle').addEventListener('input', (e) => {
            updateSlugPreview();
            updateGenerateButton();
        });

        document.getElementById('postSlug').addEventListener('input', updateSlugPreview);
        document.getElementById('postDate').addEventListener('change', updateSlugPreview);

        // Tag handling
        document.getElementById('tagInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                addTag();
            }
        });

        // Image handling
        document.getElementById('imageFiles').addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            files.forEach(file => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const date = document.getElementById('postDate').value;
                    const [year, month] = date ? date.split('-') : [new Date().getFullYear(), String(new Date().getMonth() + 1).padStart(2, '0')];
                    const imagePath = `/wp-content/uploads/${year}/${month}/${file.name}`;
                    
                    uploadedImages.push({
                        name: file.name,
                        path: imagePath,
                        data: event.target.result,
                        file: file
                    });
                    renderImageList();
                };
                reader.readAsDataURL(file);
            });
        });

        // Generate button handler
        document.getElementById('generateBtn').addEventListener('click', generatePost);

        // Download handlers
        document.getElementById('downloadZip').addEventListener('click', async () => {
            const zip = new JSZip();
            
            for (const [path, content] of Object.entries(generatedFiles)) {
                if (typeof content === 'string' && content.startsWith('data:')) {
                    const base64Data = content.split(',')[1];
                    zip.file(path, base64Data, { base64: true });
                } else {
                    zip.file(path, content);
                }
            }
            
            const blob = await zip.generateAsync({ type: 'blob' });
            const slug = getSlug();
            saveAs(blob, `blog-post-${slug}.zip`);
        });

        function renderImageList() {
            const container = document.getElementById('imageList');
            container.innerHTML = uploadedImages.map((img, index) => `
                <div class="image-item">
                    <button class="remove-image" onclick="removeImage(${index})">√ó</button>
                    <img src="${img.data}" alt="${img.name}">
                    <div class="image-path">${img.path}</div>
                    <button class="insert-image" onclick="insertImage(${index})">‚ûï Insert</button>
                    <button class="copy-path" onclick="copyPath('${img.path}')">üìã Copy</button>
                </div>
            `).join('');
        }

        function generateSlug(title) {
            return title
                .toLowerCase()
                .replace(/[^a-z0-9\s-]/g, '')
                .replace(/\s+/g, '-')
                .replace(/-+/g, '-')
                .replace(/^-|-$/g, '');
        }

        function getSlug() {
            const customSlug = document.getElementById('postSlug').value.trim();
            const titleSlug = generateSlug(document.getElementById('postTitle').value);
            return customSlug || titleSlug || 'new-post';
        }

        function updateSlugPreview() {
            const date = document.getElementById('postDate').value;
            const slug = getSlug();
            if (date) {
                const [year, month, day] = date.split('-');
                document.getElementById('slugPreview').innerHTML = 
                    `Post URL: <code>/${year}/${month}/${day}/${slug}/</code>`;
            }
        }

        function updateGenerateButton() {
            const hasHomepage = siteComponents.homepageHtml !== null;
            const hasTitle = document.getElementById('postTitle').value.trim() !== '';
            document.getElementById('generateBtn').disabled = !(hasHomepage && hasTitle);
        }

        function replaceImagesWithPaths(content) {
            let result = content;
            uploadedImages.forEach(img => {
                result = result.replaceAll(img.data, img.path);
            });
            return result;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function generatePost() {
            const title = document.getElementById('postTitle').value.trim();
            const date = document.getElementById('postDate').value;
            const slug = getSlug();
            const categoryValue = document.getElementById('postCategory').value.trim() || 'uncategorized';
            
            // Parse category - could be "slug" or "parent/slug" format
            let categorySlug, categoryParent;
            if (categoryValue.includes('/')) {
                const parts = categoryValue.split('/');
                categoryParent = parts[0];
                categorySlug = parts[1];
            } else {
                categorySlug = categoryValue;
                // Try to find parent from existing categories or selectedCategory
                const categoryObj = existingCategories.find(c => c.slug === categorySlug) || selectedCategory;
                categoryParent = categoryObj?.parent || null;
            }
            
            const rawContent = quill.root.innerHTML;
            const content = replaceImagesWithPaths(rawContent);
            
            const updateHomepage = document.getElementById('updateHomepage').checked;
            const createPostPage = document.getElementById('createPostPage').checked;
            const updateArchive = document.getElementById('updateArchive').checked;

            if (!title || !date) {
                showStatus('Please fill in the title and date', 'error');
                return;
            }

            const [year, month, day] = date.split('-');
            const dateObj = new Date(date + 'T12:00:00');
            const displayDate = dateObj.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
            const monthName = dateObj.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            const isoDate = `${date}T12:00:00+00:00`;
            const postId = 27500 + Math.floor(Math.random() * 1000);

            // Build tag classes and elements (using slug for both class and display)
            const tagSlugs = tags.map(t => generateSlug(t));
            const tagClasses = tagSlugs.map(s => 'tag-' + s).join(' ');
            const tagLinks = tags.map(t => {
                const tagSlug = generateSlug(t);
                return `<a href="/tag/${tagSlug}/" rel="tag">${escapeHtml(tagSlug)}</a>`;
            }).join(', ');

            generatedFiles = {};

            // Check if this month exists in the sidebar and update if needed
            const archiveLink = `/${year}/${month}/`;
            const monthDisplayName = dateObj.toLocaleDateString('en-US', { month: 'long' }) + ' ' + year;
            
            if (siteComponents.sidebar && !sidebarHasMonth(siteComponents.sidebar, year, month)) {
                // Update the sidebar to include this new month
                siteComponents.sidebar = addMonthToSidebar(siteComponents.sidebar, year, month, monthDisplayName);
                
                // Also update the homepage HTML if we have it (so the sidebar stays in sync)
                if (siteComponents.homepageHtml) {
                    siteComponents.homepageHtml = updateSidebarInPage(siteComponents.homepageHtml, siteComponents.sidebar);
                }
            }

            // Create article block for homepage/archive
            const articleBlock = createArticleBlock({
                postId, title, slug, year, month, day, displayDate, isoDate, 
                category: categorySlug, categoryParent, content, tagClasses, tagLinks
            });

            // Update homepage
            if (updateHomepage && siteComponents.homepageHtml) {
                const updatedHomepage = insertArticleIntoPage(siteComponents.homepageHtml, articleBlock);
                generatedFiles['index.html'] = updatedHomepage;
            }

            // Create individual post page
            if (createPostPage) {
                const postPage = createPostPage_fn({
                    postId, title, slug, year, month, day, displayDate, isoDate, 
                    category: categorySlug, categoryParent, content, tagClasses, tagLinks
                });
                generatedFiles[`${year}/${month}/${day}/${slug}/index.html`] = postPage;
            }

            // Create/update monthly archive page (always create if checkbox is checked, even without uploaded archive)
            if (updateArchive) {
                const archivePage = createArchivePage({
                    year, month, monthName, articleBlock
                });
                generatedFiles[`${year}/${month}/index.html`] = archivePage;
            }

            // Create/update yearly archive page
            const updateYearlyArchive = document.getElementById('updateYearlyArchive').checked;
            if (updateYearlyArchive) {
                const yearlyArchivePage = createYearlyArchivePage({
                    year, articleBlock
                });
                generatedFiles[`${year}/index.html`] = yearlyArchivePage;
            }

            // Generate category archive page
            if (categorySlug && categorySlug !== 'uncategorized') {
                const categoryPath = categoryParent 
                    ? `category/${categoryParent}/${categorySlug}/index.html`
                    : `category/${categorySlug}/index.html`;
                const categoryPage = createCategoryArchivePage({
                    categorySlug, categoryParent, articleBlock
                });
                generatedFiles[categoryPath] = categoryPage;
            }

            // Generate tag archive pages
            tagSlugs.forEach(tagSlug => {
                const tagPage = createTagArchivePage({
                    tagSlug, articleBlock
                });
                generatedFiles[`tag/${tagSlug}/index.html`] = tagPage;
            });

            // Add images
            uploadedImages.forEach(img => {
                const zipPath = img.path.startsWith('/') ? img.path.slice(1) : img.path;
                generatedFiles[zipPath] = img.data;
            });

            // Update file list display
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = Object.keys(generatedFiles)
                .filter(f => f.endsWith('.html'))
                .map(f => `<li>${f}</li>`).join('');

            showStatus('Files generated successfully!', 'success');
            document.getElementById('downloadSection').classList.add('show');
        }

        // Check if sidebar already has a link to a specific month
        function sidebarHasMonth(sidebarHtml, year, month) {
            const archiveLink = `/${year}/${month}/`;
            return sidebarHtml.includes(`href="${archiveLink}"`);
        }

        // Add a new month link to the sidebar archive widget (in correct chronological position)
        function addMonthToSidebar(sidebarHtml, year, month, monthDisplayName) {
            const archiveListRegex = /(<ul class="wp-block-archives-list wp-block-archives">)([\s\S]*?)(<\/ul>)/i;
            const match = sidebarHtml.match(archiveListRegex);
            
            if (!match) {
                console.warn('Could not find archive list in sidebar');
                return sidebarHtml;
            }
            
            const listContent = match[2];
            const newLink = `\t<li><a href="/${year}/${month}/">${monthDisplayName}</a></li>\n`;
            const newYearMonth = parseInt(year) * 100 + parseInt(month); // e.g., 202512 for Dec 2025
            
            // Parse existing links and find the right insertion point (reverse chronological)
            const linkRegex = /<li><a href="\/(\d{4})\/(\d{2})\/">[^<]+<\/a><\/li>/g;
            let insertPosition = 0;
            let lastMatchEnd = 0;
            let linkMatch;
            
            while ((linkMatch = linkRegex.exec(listContent)) !== null) {
                const linkYear = parseInt(linkMatch[1]);
                const linkMonth = parseInt(linkMatch[2]);
                const linkYearMonth = linkYear * 100 + linkMonth;
                
                if (newYearMonth > linkYearMonth) {
                    // New month is more recent, insert before this one
                    insertPosition = linkMatch.index;
                    break;
                }
                lastMatchEnd = linkMatch.index + linkMatch[0].length;
            }
            
            // If we didn't find a spot, append at end
            if (insertPosition === 0 && lastMatchEnd > 0) {
                insertPosition = lastMatchEnd;
                // Insert after the last link (oldest position)
                const newListContent = listContent.slice(0, insertPosition) + '\n' + newLink + listContent.slice(insertPosition);
                return sidebarHtml.replace(archiveListRegex, `$1${newListContent}$3`);
            } else if (insertPosition === 0) {
                // No existing links, add as first
                const newListContent = newLink + listContent;
                return sidebarHtml.replace(archiveListRegex, `$1${newListContent}$3`);
            } else {
                // Insert before the found position
                const newListContent = listContent.slice(0, insertPosition) + newLink + listContent.slice(insertPosition);
                return sidebarHtml.replace(archiveListRegex, `$1${newListContent}$3`);
            }
        }

        // Update the sidebar in a full page HTML
        function updateSidebarInPage(pageHtml, newSidebar) {
            const sidebarRegex = /(<aside id="primary"[\s\S]*?<\/aside>)\s*\n?\s*<\/div><!-- #container -->/i;
            return pageHtml.replace(sidebarRegex, `${newSidebar}\n</div><!-- #container -->`);
        }

        function createArticleBlock({ postId, title, slug, year, month, day, displayDate, isoDate, category, content, tagClasses, tagLinks }) {
            const tagsHtml = tagLinks ? `
                <span class="footer-tags" itemprop="keywords">
                    <i class="icon-tag icon-metas" title="Tagged"></i> ${tagLinks}
                </span>` : '';

            return `
<article id="post-${postId}" class="hentry post-${postId} post type-post status-publish format-standard category-${category} ${tagClasses}" itemscope itemtype="http://schema.org/BlogPosting" itemprop="blogPost">

    <div class="article-inner">
    <header class="entry-header">
        
        <h2 class="entry-title" itemprop="headline"><a href="/${year}/${month}/${day}/${slug}/" itemprop="mainEntityOfPage" rel="bookmark">${escapeHtml(title)}</a></h2>
        <div class="entry-meta">
            <span class="author vcard" itemscope itemtype="http://schema.org/Person" itemprop="author">
            <em>By</em>
            <a class="url fn n" rel="author" href="/author/bhwilkoff/" title="View all posts by Ben Wilkoff" itemprop="url">
                <em itemprop="name">Ben Wilkoff</em>
            </a>
        </span>
        <span class="onDate date">
            <i class="icon-time icon-metas" title="Date"></i>
            <time class="published" datetime="${isoDate}" itemprop="datePublished">${displayDate}</time>
            <time class="updated" datetime="${isoDate}" itemprop="dateModified">${displayDate}</time>
        </span>
        ${tagsHtml}
        </div><!-- .entry-meta -->

    </header><!-- .entry-header -->

    
        <div class="entry-content" itemprop="articleBody">
            ${content}
        </div><!-- .entry-content -->

        
    
    <span class="schema-publisher" itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <span itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <meta itemprop="url" content="/">
        </span>
        <meta itemprop="name" content="Learning is Change">
    </span>
    <link itemprop="mainEntityOfPage" href="/${year}/${month}/${day}/${slug}/">
    </div><!-- .article-inner -->
</article><!-- #post-${postId} -->
`;
        }

        function insertArticleIntoPage(html, articleBlock) {
            // Find content-masonry and insert after opening tag
            const masonryPattern = /(<div id="content-masonry"[^>]*>)/i;
            const match = html.match(masonryPattern);
            
            if (match) {
                const insertPos = html.indexOf(match[0]) + match[0].length;
                return html.slice(0, insertPos) + '\n' + articleBlock + html.slice(insertPos);
            }
            
            return html;
        }

        function createPostPage_fn({ postId, title, slug, year, month, day, displayDate, isoDate, category, categoryParent, content, tagClasses, tagLinks }) {
            const tagsHtml = tagLinks ? `
                <span class="footer-tags" itemprop="keywords">
                    <i class="icon-tag icon-metas" title="Tagged"></i> ${tagLinks}
                </span>` : '';

            // Update title in head
            let head = siteComponents.head || '';
            head = head.replace(/<title>[^<]*<\/title>/, `<title>${escapeHtml(title)} ‚Äì Learning is Change</title>`);

            // Extract just the header portion (everything up to </header><!-- #masthead -->)
            const headerHtml = siteComponents.header || '';

            // Build breadcrumb based on whether category has a parent
            let categoryBreadcrumb;
            if (categoryParent) {
                categoryBreadcrumb = `
                    <a href="/category/${categoryParent}/">${categoryParent}</a>
                    <i class="icon-angle-right"></i>
                    <a href="/category/${categoryParent}/${category}/">${category}</a>`;
            } else {
                categoryBreadcrumb = `<a href="/category/${category}/">${category}</a>`;
            }

            return `<!DOCTYPE html>
<html lang="en-US">
<head>${head}</head>
<body class="post-template-default single single-post single-format-standard hentry category-${category} ${tagClasses}">
    <div id="site-wrapper">
    ${headerHtml}

    <div id="breadcrumbs-container" class="cryout two-columns-left">
        <div id="breadcrumbs-container-inside">
            <div id="breadcrumbs">
                <nav id="breadcrumbs-nav">
                    <a href="/" title="Home"><i class="blicon-home2"></i><span class="screen-reader-text">Home</span></a>
                    <i class="icon-angle-right"></i>
                    ${categoryBreadcrumb}
                    <i class="icon-angle-right"></i>
                    <span class="current">${escapeHtml(title)}</span>
                </nav>
            </div>
        </div>
    </div>

    <div id="content" class="cryout">
        <div id="container" class="two-columns-left">
            <main id="main" class="main">

                <article id="post-${postId}" class="post-${postId} post type-post status-publish format-standard hentry category-${category} ${tagClasses}" itemscope itemtype="http://schema.org/Article" itemprop="mainEntity">
                    <div class="schema-image"></div>

                    <div class="article-inner">
                        <header>
                            <h1 class="entry-title" itemprop="headline">${escapeHtml(title)}</h1>
                            <div class="entry-meta">
                                <span class="author vcard" itemscope itemtype="http://schema.org/Person" itemprop="author">
                                    <em>By</em>
                                    <a class="url fn n" rel="author" href="/author/bhwilkoff/" title="View all posts by Ben Wilkoff" itemprop="url">
                                        <em itemprop="name">Ben Wilkoff</em>
                                    </a>
                                </span>
                                <span class="onDate date">
                                    <i class="icon-time icon-metas" title="Date"></i>
                                    <time class="published" datetime="${isoDate}" itemprop="datePublished">${displayDate}</time>
                                    <time class="updated" datetime="${isoDate}" itemprop="dateModified">${displayDate}</time>
                                </span>
                                ${tagsHtml}
                            </div><!-- .entry-meta -->
                        </header>

                        <div class="entry-content" itemprop="articleBody">
                            ${content}
                        </div><!-- .entry-content -->

                        <div class="author-info" itemscope itemtype="http://schema.org/Person" itemprop="author">
                            <h2 class="page-title">
                                Author: <strong itemprop="name">Ben Wilkoff</strong>
                            </h2>
                            <div class="author-avatar" itemprop="image" itemscope itemtype="http://schema.org/ImageObject">
                                <img alt="" src="https://secure.gravatar.com/avatar/0fd696e841c04ee9328d0fe05e15cf1bf82148735d92e72b5684eef4235c9faa?s=80&amp;d=mm&amp;r=g" class="avatar avatar-80 photo" height="80" width="80" itemprop="url" decoding="async">
                            </div><!-- .author-avatar -->
                            <div class="author-description" itemprop="description">
                                <span>He owns a typewriter and collects Laserdiscs. He loves his three children quite a bit (aged 11, 16 and 18). He is passionate about authentic learning, technology with purpose, and creating at least one new thing every day. In short, he teaches, and learns. A lot.</span>
                                <div class="author-link">
                                    <a href="/author/bhwilkoff/" itemprop="url">
                                        View all posts by Ben Wilkoff <span class="meta-nav">‚Üí</span>
                                    </a>
                                </div><!-- .author-link -->
                            </div><!-- .author-description -->
                        </div><!-- .author-info -->

                        <footer class="entry-meta"></footer><!-- .entry-meta -->

                        <nav id="nav-below" class="navigation" role="navigation">
                            <div class="nav-previous"></div>
                            <div class="nav-next"></div>
                        </nav><!-- #nav-below -->

                        <span class="schema-publisher" itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
                            <span itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
                                <meta itemprop="url" content="/">
                            </span>
                            <meta itemprop="name" content="Learning is Change">
                        </span>
                        <link itemprop="mainEntityOfPage" href="/${year}/${month}/${day}/${slug}/">
                    </div><!-- .article-inner -->
                </article><!-- #post-## -->

            </main><!-- #main -->

            ${siteComponents.sidebar || ''}
        </div><!-- #container -->

    ${siteComponents.footer || ''}
    ${siteComponents.scripts || ''}
</body>
</html>`;
        }

        function createArchivePage({ year, month, monthName, articleBlock }) {
            // If we have an existing archive, insert into it
            if (siteComponents.archiveHtml) {
                return insertArticleIntoPage(siteComponents.archiveHtml, articleBlock);
            }

            // Otherwise create a new archive page from homepage structure
            let head = siteComponents.head || '';
            head = head.replace(/<title>[^<]*<\/title>/, `<title>${monthName} ‚Äì Learning is Change</title>`);
            
            const monthNameOnly = new Date(year, parseInt(month) - 1).toLocaleDateString('en-US', { month: 'long' });

            return `<!DOCTYPE html>
<html lang="en-US">
<head>${head}</head>
<body class="archive date">
    ${siteComponents.header || '<div id="site-wrapper">'}

    <div id="breadcrumbs-container" class="cryout two-columns-left">
        <div id="breadcrumbs-container-inside">
            <div id="breadcrumbs">
                <nav id="breadcrumbs-nav">
                    <a href="/" title="Home"><i class="blicon-home2"></i><span class="screen-reader-text">Home</span></a>
                    <i class="icon-angle-right"></i>
                    <a href="/${year}/">${year}</a>
                    <i class="icon-angle-right"></i>
                    <span class="current">${monthNameOnly}</span>
                </nav>
            </div>
        </div>
    </div><!-- breadcrumbs -->

    <div id="content" class="cryout">
        <div id="container" class="two-columns-left">
            <main id="main" class="main">

                <header class="page-header pad-container" itemscope itemtype="http://schema.org/WebPageElement">
                    <h1 class="page-title" itemprop="headline">Month: <span>${monthName}</span></h1>
                </header><!-- .page-header -->

                <div id="content-masonry" class="content-masonry" itemscope itemtype="http://schema.org/Blog">
${articleBlock}
                </div><!--content-masonry-->

            </main><!-- #main -->

            ${siteComponents.sidebar || ''}
        </div><!-- #container -->

    ${siteComponents.footer || ''}
    ${siteComponents.scripts || ''}
</body>
</html>`;
        }

        // Create yearly archive page
        function createYearlyArchivePage({ year, articleBlock }) {
            // If we have an existing yearly archive, insert into it
            if (siteComponents.yearlyArchiveHtml) {
                return insertArticleIntoPage(siteComponents.yearlyArchiveHtml, articleBlock);
            }

            // Otherwise create a new yearly archive page from homepage structure
            let head = siteComponents.head || '';
            head = head.replace(/<title>[^<]*<\/title>/, `<title>${year} ‚Äì Learning is Change</title>`);

            return `<!DOCTYPE html>
<html lang="en-US">
<head>${head}</head>
<body class="archive date">
    ${siteComponents.header || '<div id="site-wrapper">'}

    <div id="breadcrumbs-container" class="cryout two-columns-left">
        <div id="breadcrumbs-container-inside">
            <div id="breadcrumbs">
                <nav id="breadcrumbs-nav">
                    <a href="/" title="Home"><i class="blicon-home2"></i><span class="screen-reader-text">Home</span></a>
                    <i class="icon-angle-right"></i>
                    <span class="current">${year}</span>
                </nav>
            </div>
        </div>
    </div><!-- breadcrumbs -->

    <div id="content" class="cryout">
        <div id="container" class="two-columns-left">
            <main id="main" class="main">

                <header class="page-header pad-container" itemscope itemtype="http://schema.org/WebPageElement">
                    <h1 class="page-title" itemprop="headline">Year: <span>${year}</span></h1>
                </header><!-- .page-header -->

                <div id="content-masonry" class="content-masonry" itemscope itemtype="http://schema.org/Blog">
${articleBlock}
                </div><!--content-masonry-->

            </main><!-- #main -->

            ${siteComponents.sidebar || ''}
        </div><!-- #container -->

    ${siteComponents.footer || ''}
    ${siteComponents.scripts || ''}
</body>
</html>`;
        }

        // Create category archive page
        function createCategoryArchivePage({ categorySlug, categoryParent, articleBlock }) {
            let head = siteComponents.head || '';
            head = head.replace(/<title>[^<]*<\/title>/, `<title>${categorySlug} ‚Äì Learning is Change</title>`);

            // Build breadcrumb based on whether category has a parent
            let categoryBreadcrumb;
            if (categoryParent) {
                categoryBreadcrumb = `
                    <a href="/category/${categoryParent}/">${categoryParent}</a>
                    <i class="icon-angle-right"></i>
                    <span class="current">Archive for category "${categorySlug}"</span>`;
            } else {
                categoryBreadcrumb = `<span class="current">Archive for category "${categorySlug}"</span>`;
            }

            return `<!DOCTYPE html>
<html lang="en-US">
<head>${head}</head>
<body class="archive category category-${categorySlug}">
    ${siteComponents.header || '<div id="site-wrapper">'}

    <div id="breadcrumbs-container" class="cryout two-columns-left">
        <div id="breadcrumbs-container-inside">
            <div id="breadcrumbs">
                <nav id="breadcrumbs-nav">
                    <a href="/" title="Home"><i class="blicon-home2"></i><span class="screen-reader-text">Home</span></a>
                    <i class="icon-angle-right"></i>
                    ${categoryBreadcrumb}
                </nav>
            </div>
        </div>
    </div><!-- breadcrumbs -->

    <div id="content" class="cryout">
        <div id="container" class="two-columns-left">
            <main id="main" class="main">

                <header class="page-header pad-container" itemscope itemtype="http://schema.org/WebPageElement">
                    <h1 class="page-title" itemprop="headline">Category: <span>${categorySlug}</span></h1>
                </header><!-- .page-header -->

                <div id="content-masonry" class="content-masonry" itemscope itemtype="http://schema.org/Blog">
${articleBlock}
                </div><!--content-masonry-->

            </main><!-- #main -->

            ${siteComponents.sidebar || ''}
        </div><!-- #container -->

    ${siteComponents.footer || ''}
    ${siteComponents.scripts || ''}
</body>
</html>`;
        }

        // Create tag archive page
        function createTagArchivePage({ tagSlug, articleBlock }) {
            let head = siteComponents.head || '';
            head = head.replace(/<title>[^<]*<\/title>/, `<title>${tagSlug} ‚Äì Learning is Change</title>`);

            return `<!DOCTYPE html>
<html lang="en-US">
<head>${head}</head>
<body class="archive tag tag-${tagSlug}">
    ${siteComponents.header || '<div id="site-wrapper">'}

    <div id="breadcrumbs-container" class="cryout two-columns-left">
        <div id="breadcrumbs-container-inside">
            <div id="breadcrumbs">
                <nav id="breadcrumbs-nav">
                    <a href="/" title="Home"><i class="blicon-home2"></i><span class="screen-reader-text">Home</span></a>
                    <i class="icon-angle-right"></i>
                    <span class="current">Posts tagged "${tagSlug}"</span>
                </nav>
            </div>
        </div>
    </div><!-- breadcrumbs -->

    <div id="content" class="cryout">
        <div id="container" class="two-columns-left">
            <main id="main" class="main">

                <header class="page-header pad-container" itemscope itemtype="http://schema.org/WebPageElement">
                    <h1 class="page-title" itemprop="headline">Tag: <span>${tagSlug}</span></h1>
                </header><!-- .page-header -->

                <div id="content-masonry" class="content-masonry" itemscope itemtype="http://schema.org/Blog">
${articleBlock}
                </div><!--content-masonry-->

            </main><!-- #main -->

            ${siteComponents.sidebar || ''}
        </div><!-- #container -->

    ${siteComponents.footer || ''}
    ${siteComponents.scripts || ''}
</body>
</html>`;
        }

        function showStatus(message, type) {
            const el = document.getElementById('statusMessage');
            el.className = `status ${type}`;
            el.textContent = message;
        }

        // GitHub fetch functions (need access to extractSiteComponents, updateExtractedInfo, etc.)
        async function fetchFileFromGithub(owner, repo, path, token) {
            try {
                const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Accept': 'application/vnd.github.raw+json',
                        'X-GitHub-Api-Version': '2022-11-28'
                    }
                });
                
                if (response.ok) {
                    return await response.text();
                } else if (response.status === 404) {
                    return null; // File doesn't exist
                } else {
                    throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                if (error.message.includes('404')) {
                    return null;
                }
                throw error;
            }
        }

        async function fetchFromGithub() {
            const token = document.getElementById('githubToken').value.trim();
            const repo = document.getElementById('githubRepo').value.trim();
            const fetchStatus = document.getElementById('fetchStatus');
            
            if (!token || !repo) {
                // Open GitHub settings if not configured
                document.getElementById('githubSettings').classList.add('open');
                fetchStatus.className = 'fetch-status show error';
                fetchStatus.textContent = '‚ö†Ô∏è Please configure GitHub token and repository in settings below first';
                return;
            }
            
            const [owner, repoName] = repo.split('/');
            if (!owner || !repoName) {
                fetchStatus.className = 'fetch-status show error';
                fetchStatus.textContent = '‚ö†Ô∏è Repository format should be: owner/repo';
                return;
            }
            
            const fetchBtn = document.getElementById('fetchFromGithub');
            fetchBtn.disabled = true;
            fetchStatus.className = 'fetch-status show loading';
            fetchStatus.textContent = '‚è≥ Fetching homepage from GitHub...';
            
            try {
                // Fetch homepage (index.html)
                const homepageContent = await fetchFileFromGithub(owner, repoName, 'index.html', token);
                
                if (homepageContent) {
                    // Process the homepage just like an uploaded file
                    siteComponents.homepageHtml = homepageContent;
                    extractSiteComponents(homepageContent);
                    
                    // Update UI to show homepage is loaded
                    document.getElementById('homepageUpload').classList.add('has-file');
                    document.getElementById('homepageUpload').querySelector('.file-upload-icon').textContent = '‚úÖ';
                    
                    fetchStatus.textContent = '‚úÖ Homepage loaded! ';
                    
                    // Try to fetch archive pages for the selected date
                    const date = document.getElementById('postDate').value;
                    if (date) {
                        const [year, month] = date.split('-');
                        fetchStatus.textContent += `Checking for ${year}/${month} archive...`;
                        
                        // Fetch monthly archive
                        const archiveContent = await fetchFileFromGithub(owner, repoName, `${year}/${month}/index.html`, token);
                        
                        if (archiveContent) {
                            siteComponents.archiveHtml = archiveContent;
                            document.getElementById('archiveUpload').classList.add('has-file');
                            document.getElementById('archiveUpload').querySelector('.file-upload-icon').textContent = '‚úÖ';
                            fetchStatus.textContent = `‚úÖ Homepage and ${year}/${month} archive loaded! `;
                        } else {
                            fetchStatus.textContent = `‚úÖ Homepage loaded! (No ${year}/${month} archive yet) `;
                        }
                        
                        // Fetch yearly archive
                        fetchStatus.textContent += `Checking for ${year} yearly archive...`;
                        const yearlyArchiveContent = await fetchFileFromGithub(owner, repoName, `${year}/index.html`, token);
                        
                        if (yearlyArchiveContent) {
                            siteComponents.yearlyArchiveHtml = yearlyArchiveContent;
                        }
                    }
                    
                    // Fetch existing categories and tags
                    fetchStatus.textContent += 'Fetching categories...';
                    await fetchExistingTaxonomies(owner, repoName, token);
                    
                    fetchStatus.className = 'fetch-status show success';
                    fetchStatus.textContent = `‚úÖ Loaded: Homepage, ${existingCategories.length} categories, ${existingTags.length} tags`;
                    
                    updateExtractedInfo();
                    updateGenerateButton();
                    updateTaxonomyUI();
                } else {
                    fetchStatus.className = 'fetch-status show error';
                    fetchStatus.textContent = '‚ùå Could not find index.html in repository';
                }
            } catch (error) {
                console.error('Fetch from GitHub error:', error);
                fetchStatus.className = 'fetch-status show error';
                fetchStatus.textContent = `‚ùå Error: ${error.message}`;
            }
            
            fetchBtn.disabled = false;
        }
        window.fetchFromGithub = fetchFromGithub;

        // Fetch existing categories and tags from GitHub directory structure
        async function fetchExistingTaxonomies(owner, repo, token) {
            existingCategories = [];
            existingTags = [];
            
            // Fetch categories
            try {
                const categoryDir = await fetchDirectoryFromGithub(owner, repo, 'category', token);
                if (categoryDir) {
                    for (const item of categoryDir) {
                        if (item.type === 'dir') {
                            existingCategories.push({
                                slug: item.name,
                                parent: null,
                                path: `/category/${item.name}/`
                            });
                            
                            // Check for nested categories (skip 'page' directories used for pagination)
                            const subDir = await fetchDirectoryFromGithub(owner, repo, `category/${item.name}`, token);
                            if (subDir) {
                                for (const subItem of subDir) {
                                    // Skip 'page' directories (pagination) and index.html files
                                    if (subItem.type === 'dir' && subItem.name !== 'index.html' && subItem.name !== 'page') {
                                        existingCategories.push({
                                            slug: subItem.name,
                                            parent: item.name,
                                            path: `/category/${item.name}/${subItem.name}/`
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            } catch (e) {
                console.log('No category directory found or error:', e);
            }
            
            // Fetch tags
            try {
                const tagDir = await fetchDirectoryFromGithub(owner, repo, 'tag', token);
                if (tagDir) {
                    for (const item of tagDir) {
                        // Skip 'page' directories (pagination)
                        if (item.type === 'dir' && item.name !== 'page') {
                            existingTags.push({
                                slug: item.name,
                                path: `/tag/${item.name}/`
                            });
                        }
                    }
                }
            } catch (e) {
                console.log('No tag directory found or error:', e);
            }
            
            console.log('Fetched categories:', existingCategories);
            console.log('Fetched tags:', existingTags);
        }

        async function fetchDirectoryFromGithub(owner, repo, path, token) {
            try {
                const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'X-GitHub-Api-Version': '2022-11-28'
                    }
                });
                
                if (response.ok) {
                    return await response.json();
                } else if (response.status === 404) {
                    return null;
                } else {
                    throw new Error(`GitHub API error: ${response.status}`);
                }
            } catch (error) {
                if (error.message.includes('404')) {
                    return null;
                }
                throw error;
            }
        }

        // Update the category/tag UI with fetched data
        function updateTaxonomyUI() {
            // Update category badge
            const categoryBadge = document.getElementById('categoryBadge');
            if (existingCategories.length > 0) {
                categoryBadge.textContent = `${existingCategories.length} fetched`;
                categoryBadge.style.display = 'inline-block';
            }
            
            // Update tag badge
            const tagBadge = document.getElementById('tagBadge');
            if (existingTags.length > 0) {
                tagBadge.textContent = `${existingTags.length} fetched`;
                tagBadge.style.display = 'inline-block';
            }
            
            // Update parent category dropdown
            const parentSelect = document.getElementById('parentCategory');
            parentSelect.innerHTML = '<option value="">No parent (top-level)</option>';
            existingCategories.filter(c => !c.parent).forEach(cat => {
                parentSelect.innerHTML += `<option value="${cat.slug}">${cat.slug}</option>`;
            });
            
            // Update tag datalist
            const tagDatalist = document.getElementById('existingTagsList');
            tagDatalist.innerHTML = existingTags.map(t => `<option value="${t.slug}">`).join('');
            
            // Show quick-add tags
            const existingTagsHint = document.getElementById('existingTagsHint');
            const quickAddContainer = document.getElementById('existingTagsQuickAdd');
            if (existingTags.length > 0) {
                existingTagsHint.style.display = 'block';
                quickAddContainer.innerHTML = existingTags.slice(0, 10).map(t => 
                    `<span onclick="quickAddTag('${t.slug}')">${t.slug}</span>`
                ).join('');
            }
            
            // Setup category dropdown
            setupCategoryDropdown();
        }
        window.updateTaxonomyUI = updateTaxonomyUI;

        function setupCategoryDropdown() {
            const input = document.getElementById('postCategory');
            const dropdown = document.getElementById('categoryDropdown');
            
            input.addEventListener('focus', () => showCategoryDropdown());
            input.addEventListener('input', () => showCategoryDropdown());
            input.addEventListener('blur', () => {
                // Delay hiding to allow click events
                setTimeout(() => dropdown.classList.remove('show'), 200);
            });
        }

        function showCategoryDropdown() {
            const input = document.getElementById('postCategory');
            const dropdown = document.getElementById('categoryDropdown');
            const filter = input.value.toLowerCase();
            
            let html = '';
            
            // Show matching existing categories (filter on slug or parent/slug)
            const filtered = existingCategories.filter(c => {
                const fullPath = c.parent ? `${c.parent}/${c.slug}` : c.slug;
                return fullPath.toLowerCase().includes(filter) || c.slug.toLowerCase().includes(filter);
            });
            
            // Group by parent
            const topLevel = filtered.filter(c => !c.parent);
            const nested = filtered.filter(c => c.parent);
            
            topLevel.forEach(cat => {
                html += `<div class="taxonomy-option" onclick="selectCategory('${cat.slug}', null)">${cat.slug}</div>`;
                // Show children of this category indented below parent
                nested.filter(c => c.parent === cat.slug).forEach(child => {
                    html += `<div class="taxonomy-option nested" onclick="selectCategory('${child.slug}', '${child.parent}')">${child.parent}/${child.slug}</div>`;
                });
            });
            
            // Show nested categories whose parent wasn't in filtered results
            nested.filter(c => !topLevel.find(t => t.slug === c.parent)).forEach(child => {
                html += `<div class="taxonomy-option nested" onclick="selectCategory('${child.slug}', '${child.parent}')">${child.parent}/${child.slug}</div>`;
            });
            
            // Add "create new" option
            html += `<div class="taxonomy-option add-new" onclick="showNewCategoryForm()">+ Add new category...</div>`;
            
            dropdown.innerHTML = html;
            dropdown.classList.add('show');
        }

        function selectCategory(slug, parent) {
            // Show full path format: "parent/child" for nested categories
            const displayValue = parent ? `${parent}/${slug}` : slug;
            document.getElementById('postCategory').value = displayValue;
            selectedCategory = { slug, parent };
            document.getElementById('categoryDropdown').classList.remove('show');
            document.getElementById('newCategoryForm').classList.remove('show');
        }
        window.selectCategory = selectCategory;

        function showNewCategoryForm() {
            document.getElementById('newCategoryForm').classList.add('show');
            document.getElementById('newCategorySlug').focus();
            document.getElementById('categoryDropdown').classList.remove('show');
            updateCategoryPreview();
            
            // Set up live preview updates
            document.getElementById('newCategorySlug').addEventListener('input', updateCategoryPreview);
            document.getElementById('parentCategory').addEventListener('change', updateCategoryPreview);
        }
        window.showNewCategoryForm = showNewCategoryForm;

        function updateCategoryPreview() {
            const slug = document.getElementById('newCategorySlug').value.trim().toLowerCase().replace(/[^a-z0-9-]/g, '-');
            const parent = document.getElementById('parentCategory').value;
            const preview = document.getElementById('categoryPreview');
            
            if (slug) {
                const fullPath = parent ? `${parent}/${slug}` : slug;
                preview.innerHTML = `Will create: <strong>/category/${fullPath}/</strong>`;
            } else {
                preview.innerHTML = '';
            }
        }

        function addNewCategory() {
            const slug = document.getElementById('newCategorySlug').value.trim().toLowerCase().replace(/[^a-z0-9-]/g, '-');
            const parent = document.getElementById('parentCategory').value || null;
            
            if (!slug) {
                alert('Please enter a category slug');
                return;
            }
            
            // Add to existing categories
            existingCategories.push({
                slug,
                parent,
                path: parent ? `/category/${parent}/${slug}/` : `/category/${slug}/`
            });
            
            // Select the new category (this will show full path format)
            selectCategory(slug, parent);
            
            // Clear form
            document.getElementById('newCategorySlug').value = '';
            document.getElementById('parentCategory').value = '';
            document.getElementById('categoryPreview').innerHTML = '';
            document.getElementById('newCategoryForm').classList.remove('show');
            
            // Update UI
            updateTaxonomyUI();
        }
        window.addNewCategory = addNewCategory;

        function cancelNewCategory() {
            document.getElementById('newCategoryForm').classList.remove('show');
            document.getElementById('newCategorySlug').value = '';
            document.getElementById('categoryPreview').innerHTML = '';
        }
        window.cancelNewCategory = cancelNewCategory;

        function quickAddTag(slug) {
            if (!tags.includes(slug)) {
                tags.push(slug);
                renderTags();
            }
        }
        window.quickAddTag = quickAddTag;

        // Auto-fetch archive when date changes (if homepage already loaded from GitHub)
        function setupDateChangeHandler() {
            const dateInput = document.getElementById('postDate');
            
            dateInput.addEventListener('change', async () => {
                // Only auto-fetch if we loaded from GitHub and have a token
                const token = document.getElementById('githubToken').value.trim();
                const repo = document.getElementById('githubRepo').value.trim();
                const fetchStatus = document.getElementById('fetchStatus');
                
                if (token && repo && siteComponents.homepageHtml && fetchStatus.classList.contains('success')) {
                    const [owner, repoName] = repo.split('/');
                    const date = dateInput.value;
                    
                    if (date && owner && repoName) {
                        const [year, month] = date.split('-');
                        fetchStatus.textContent = `Checking for ${year}/${month} archive...`;
                        fetchStatus.className = 'fetch-status show loading';
                        
                        try {
                            // Fetch monthly archive
                            const archiveContent = await fetchFileFromGithub(owner, repoName, `${year}/${month}/index.html`, token);
                            
                            if (archiveContent) {
                                siteComponents.archiveHtml = archiveContent;
                                document.getElementById('archiveUpload').classList.add('has-file');
                                document.getElementById('archiveUpload').querySelector('.file-upload-icon').textContent = '‚úÖ';
                                fetchStatus.textContent = `‚úÖ Found existing archive for ${year}/${month}`;
                            } else {
                                siteComponents.archiveHtml = null;
                                document.getElementById('archiveUpload').classList.remove('has-file');
                                document.getElementById('archiveUpload').querySelector('.file-upload-icon').textContent = 'üìÖ';
                                fetchStatus.textContent = `‚úÖ No existing archive for ${year}/${month} - will create new`;
                            }
                            
                            // Fetch yearly archive
                            const yearlyArchiveContent = await fetchFileFromGithub(owner, repoName, `${year}/index.html`, token);
                            siteComponents.yearlyArchiveHtml = yearlyArchiveContent || null;
                            
                            fetchStatus.className = 'fetch-status show success';
                        } catch (error) {
                            console.error('Error fetching archive:', error);
                            fetchStatus.textContent = `‚ö†Ô∏è Could not check archive: ${error.message}`;
                            fetchStatus.className = 'fetch-status show error';
                        }
                    }
                }
            });
        }

        // Initialize
        updateSlugPreview();
        loadGithubSettings();
        setupDateChangeHandler();
    } // end initApp

    // Global functions for onclick handlers
    function addTag() {
        const input = document.getElementById('tagInput');
        const tag = input.value.trim();
        if (tag && !tags.includes(tag)) {
            tags.push(tag);
            renderTags();
        }
        input.value = '';
    }
    window.addTag = addTag;

    function removeTag(index) {
        tags.splice(index, 1);
        renderTags();
    }
    window.removeTag = removeTag;

    function renderTags() {
        const container = document.getElementById('tagsList');
        container.innerHTML = tags.map((tag, index) => `
            <span class="tag">
                ${tag}
                <button onclick="removeTag(${index})">√ó</button>
            </span>
        `).join('');
    }

    function insertImage(index) {
        const img = uploadedImages[index];
        const range = quill.getSelection(true) || { index: quill.getLength() };
        quill.insertEmbed(range.index, 'image', img.data);
        quill.setSelection(range.index + 1);
    }
    window.insertImage = insertImage;

    function removeImage(index) {
        uploadedImages.splice(index, 1);
        const container = document.getElementById('imageList');
        container.innerHTML = uploadedImages.map((img, i) => `
            <div class="image-item">
                <button class="remove-image" onclick="removeImage(${i})">√ó</button>
                <img src="${img.data}" alt="${img.name}">
                <div class="image-path">${img.path}</div>
                <button class="insert-image" onclick="insertImage(${i})">‚ûï Insert</button>
                <button class="copy-path" onclick="copyPath('${img.path}')">üìã Copy</button>
            </div>
        `).join('');
    }
    window.removeImage = removeImage;

    function copyPath(path) {
        navigator.clipboard.writeText(path);
    }
    window.copyPath = copyPath;

    // GitHub Integration Functions
    function toggleGithubSettings() {
        const section = document.getElementById('githubSettings');
        section.classList.toggle('open');
    }
    window.toggleGithubSettings = toggleGithubSettings;

    function toggleTokenVisibility() {
        const input = document.getElementById('githubToken');
        const btn = document.querySelector('.token-toggle');
        if (input.type === 'password') {
            input.type = 'text';
            btn.textContent = 'üôà';
        } else {
            input.type = 'password';
            btn.textContent = 'üëÅÔ∏è';
        }
    }
    window.toggleTokenVisibility = toggleTokenVisibility;

    function loadGithubSettings() {
        const saved = localStorage.getItem('githubSettings');
        if (saved) {
            try {
                const settings = JSON.parse(saved);
                if (settings.token) document.getElementById('githubToken').value = settings.token;
                if (settings.repo) document.getElementById('githubRepo').value = settings.repo;
                if (settings.name) document.getElementById('committerName').value = settings.name;
                if (settings.email) document.getElementById('committerEmail').value = settings.email;
                document.getElementById('saveToken').checked = !!settings.token;
                updateGithubStatus('connected', `Connected to ${settings.repo}`);
            } catch (e) {
                console.error('Error loading GitHub settings:', e);
            }
        }
    }

    function saveGithubSettings() {
        const shouldSaveToken = document.getElementById('saveToken').checked;
        const settings = {
            token: shouldSaveToken ? document.getElementById('githubToken').value : '',
            repo: document.getElementById('githubRepo').value,
            name: document.getElementById('committerName').value,
            email: document.getElementById('committerEmail').value
        };
        localStorage.setItem('githubSettings', JSON.stringify(settings));
    }

    function clearGithubSettings() {
        if (confirm('Clear all saved GitHub settings?')) {
            localStorage.removeItem('githubSettings');
            document.getElementById('githubToken').value = '';
            document.getElementById('githubRepo').value = '';
            document.getElementById('committerName').value = '';
            document.getElementById('committerEmail').value = '';
            document.getElementById('saveToken').checked = false;
            updateGithubStatus('disconnected', 'Settings cleared');
        }
    }
    window.clearGithubSettings = clearGithubSettings;

    function updateGithubStatus(type, message) {
        const status = document.getElementById('githubStatus');
        status.className = `github-status ${type}`;
        status.innerHTML = type === 'connected' 
            ? `<span>‚úÖ</span> ${message}`
            : `<span>‚ÑπÔ∏è</span> ${message}`;
    }

    async function testGithubConnection() {
        const token = document.getElementById('githubToken').value.trim();
        const repo = document.getElementById('githubRepo').value.trim();
        
        if (!token || !repo) {
            updateGithubStatus('disconnected', 'Please enter your token and repository');
            return;
        }
        
        updateGithubStatus('disconnected', 'Testing connection...');
        
        try {
            const [owner, repoName] = repo.split('/');
            if (!owner || !repoName) {
                updateGithubStatus('disconnected', 'Repository format should be: owner/repo');
                return;
            }
            
            const response = await fetch(`https://api.github.com/repos/${owner}/${repoName}`, {
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Accept': 'application/vnd.github+json',
                    'X-GitHub-Api-Version': '2022-11-28'
                }
            });
            
            if (response.ok) {
                const data = await response.json();
                updateGithubStatus('connected', `Connected to ${data.full_name}`);
                saveGithubSettings();
            } else if (response.status === 401) {
                updateGithubStatus('disconnected', 'Invalid token - check your Personal Access Token');
            } else if (response.status === 404) {
                updateGithubStatus('disconnected', 'Repository not found - check owner/repo format');
            } else {
                updateGithubStatus('disconnected', `Error: ${response.status} ${response.statusText}`);
            }
        } catch (error) {
            updateGithubStatus('disconnected', `Connection error: ${error.message}`);
        }
    }
    window.testGithubConnection = testGithubConnection;

    async function publishToGithub() {
        const token = document.getElementById('githubToken').value.trim();
        const repo = document.getElementById('githubRepo').value.trim();
        const committerName = document.getElementById('committerName').value.trim() || 'Blog Generator';
        const committerEmail = document.getElementById('committerEmail').value.trim() || 'noreply@example.com';
        
        if (!token || !repo) {
            alert('Please configure GitHub settings first (expand the GitHub Publishing Settings section)');
            document.getElementById('githubSettings').classList.add('open');
            return;
        }
        
        const filePaths = Object.keys(generatedFiles);
        if (filePaths.length === 0) {
            alert('No files to publish. Please generate files first.');
            return;
        }
        
        const [owner, repoName] = repo.split('/');
        if (!owner || !repoName) {
            alert('Repository format should be: owner/repo');
            return;
        }
        
        const publishBtn = document.getElementById('publishGithub');
        const progressContainer = document.getElementById('publishProgress');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        
        publishBtn.disabled = true;
        progressBar.style.background = 'var(--accent-1)';
        progressBar.style.width = '0%';
        progressContainer.classList.add('show');
        
        const postTitle = document.getElementById('postTitle').value.trim();
        const commitMessage = `Add new post: ${postTitle}`;
        
        try {
            // Use Git Data API for single commit with all files
            await createSingleCommit(owner, repoName, token, committerName, committerEmail, commitMessage, progressBar, progressText);
            
            progressBar.style.width = '100%';
            progressText.textContent = `‚úÖ Successfully published ${filePaths.length} file(s) to GitHub in a single commit!`;
            progressBar.style.background = '#28a745';
            saveGithubSettings();
        } catch (error) {
            console.error('GitHub publish error:', error);
            progressText.textContent = `‚ùå Error: ${error.message}`;
            progressBar.style.background = '#dc3545';
        }
        
        publishBtn.disabled = false;
    }
    window.publishToGithub = publishToGithub;

    async function createSingleCommit(owner, repo, token, committerName, committerEmail, message, progressBar, progressText) {
        const headers = {
            'Authorization': `Bearer ${token}`,
            'Accept': 'application/vnd.github+json',
            'X-GitHub-Api-Version': '2022-11-28',
            'Content-Type': 'application/json'
        };
        
        const filePaths = Object.keys(generatedFiles);
        const totalSteps = filePaths.length + 4; // blobs + get ref + get commit + create tree + create commit + update ref
        let currentStep = 0;
        
        const updateProgress = (stepText) => {
            currentStep++;
            const progress = Math.round((currentStep / totalSteps) * 100);
            progressBar.style.width = `${progress}%`;
            progressText.textContent = stepText;
        };
        
        // Step 1: Get the current commit SHA (HEAD of main branch)
        updateProgress('Getting current branch state...');
        const refResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/ref/heads/main`, { headers });
        if (!refResponse.ok) {
            throw new Error('Failed to get branch reference. Make sure the main branch exists.');
        }
        const refData = await refResponse.json();
        const currentCommitSha = refData.object.sha;
        
        // Step 2: Get the current commit to find its tree
        updateProgress('Getting current tree...');
        const commitResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/commits/${currentCommitSha}`, { headers });
        if (!commitResponse.ok) {
            throw new Error('Failed to get current commit.');
        }
        const commitData = await commitResponse.json();
        const baseTreeSha = commitData.tree.sha;
        
        // Step 3: Create blobs for each file
        const treeItems = [];
        for (const filePath of filePaths) {
            updateProgress(`Creating blob for ${filePath}...`);
            const content = generatedFiles[filePath];
            
            let base64Content;
            if (typeof content === 'string' && content.startsWith('data:')) {
                // For data URLs (images), extract just the base64 part
                base64Content = content.split(',')[1];
            } else if (typeof content === 'string') {
                // For text content (HTML files), encode to base64
                const encoder = new TextEncoder();
                const bytes = encoder.encode(content);
                base64Content = btoa(String.fromCharCode(...bytes));
            } else {
                base64Content = content;
            }
            
            const blobResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/blobs`, {
                method: 'POST',
                headers,
                body: JSON.stringify({
                    content: base64Content,
                    encoding: 'base64'
                })
            });
            
            if (!blobResponse.ok) {
                throw new Error(`Failed to create blob for ${filePath}`);
            }
            
            const blobData = await blobResponse.json();
            treeItems.push({
                path: filePath,
                mode: '100644', // Regular file
                type: 'blob',
                sha: blobData.sha
            });
        }
        
        // Step 4: Create a new tree with all the blobs
        updateProgress('Creating new tree...');
        const treeResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees`, {
            method: 'POST',
            headers,
            body: JSON.stringify({
                base_tree: baseTreeSha,
                tree: treeItems
            })
        });
        
        if (!treeResponse.ok) {
            throw new Error('Failed to create tree');
        }
        const treeData = await treeResponse.json();
        
        // Step 5: Create the commit
        updateProgress('Creating commit...');
        const newCommitResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/commits`, {
            method: 'POST',
            headers,
            body: JSON.stringify({
                message: message,
                tree: treeData.sha,
                parents: [currentCommitSha],
                author: {
                    name: committerName,
                    email: committerEmail,
                    date: new Date().toISOString()
                },
                committer: {
                    name: committerName,
                    email: committerEmail,
                    date: new Date().toISOString()
                }
            })
        });
        
        if (!newCommitResponse.ok) {
            throw new Error('Failed to create commit');
        }
        const newCommitData = await newCommitResponse.json();
        
        // Step 6: Update the branch reference to point to the new commit
        updateProgress('Updating branch...');
        const updateRefResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/main`, {
            method: 'PATCH',
            headers,
            body: JSON.stringify({
                sha: newCommitData.sha,
                force: false
            })
        });
        
        if (!updateRefResponse.ok) {
            throw new Error('Failed to update branch reference');
        }
        
        return newCommitData;
    }

    async function uploadFileToGithub(owner, repo, path, content, token, committerName, committerEmail, message) {
        // Kept for potential future use, but no longer used by publishToGithub
        let sha = null;
        
        try {
            const checkResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Accept': 'application/vnd.github+json',
                    'X-GitHub-Api-Version': '2022-11-28'
                }
            });
            
            if (checkResponse.ok) {
                const existingFile = await checkResponse.json();
                sha = existingFile.sha;
            }
        } catch (e) {
            // File doesn't exist
        }
        
        let base64Content;
        if (typeof content === 'string' && content.startsWith('data:')) {
            base64Content = content.split(',')[1];
        } else if (typeof content === 'string') {
            const encoder = new TextEncoder();
            const bytes = encoder.encode(content);
            base64Content = btoa(String.fromCharCode(...bytes));
        } else {
            base64Content = content;
        }
        
        const body = {
            message: message,
            content: base64Content,
            committer: { name: committerName, email: committerEmail }
        };
        
        if (sha) body.sha = sha;
        
        const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
            method: 'PUT',
            headers: {
                'Authorization': `Bearer ${token}`,
                'Accept': 'application/vnd.github+json',
                'X-GitHub-Api-Version': '2022-11-28',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
        });
        
        if (!response.ok) {
            const error = await response.json();
            throw new Error(`GitHub API error: ${error.message || response.statusText}`);
        }
        
        return await response.json();
    }

    // Wait for DOM and then initialize
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initApp);
    } else {
        initApp();
    }
    </script>
    
    <footer class="site-footer">
        Static Blog Post Generator for <a href="https://learningischange.com">Learning is Change</a><br>
        Works offline ‚Ä¢ GitHub integration optional ‚Ä¢ Your token stays in your browser
    </footer>
</body>
</html>
